keycloak:
  realm: OVERRIDE_VIA_CUSTOM_VALUES

bitwardenIds:
  crowdsec-secret: OVERRIDE_VIA_CUSTOM_VALUES
  traefik-sso-secret: OVERRIDE_VIA_CUSTOM_VALUES
  traefik-mqtt: OVERRIDE_VIA_CUSTOM_VALUES

domain: OVERRIDE_VIA_APPSET
clusterName: OVERRIDE_VIA_APPSET
namespace: OVERRIDE_VIA_APPSET

cert-manager:
  installCRDs: true

traefik:
  fullnameOverride: "traefik"

  additionalArguments:
    - "--api"
    - "--api.dashboard=true"
    - "--api.insecure=true"
    - "--serversTransport.insecureSkipVerify=true"
    - "--providers.file.filename=/data/user-allowlist.yaml"
    - "--providers.file.watch=true"
    # Force all port 80 traffic to 443
    - "--entrypoints.web.http.redirections.entrypoint.to=websecure"
    - "--entrypoints.web.http.redirections.entrypoint.scheme=https"
    - "--entrypoints.web.http.redirections.entrypoint.permanent=true"
  dashboard:
    enabled: true

  ingressClass:
    enabled: true
    name: "traefik"  # Change from "proxy-local-traefik"

  persistence:
    enabled: true
    existingClaim: "proxy-allowlist"
    accessMode: ReadWriteMany
    # existingClaim: ""
    # size: 1Gi

  providers:
    kubernetesCRD:
      allowCrossNamespace: true
      allowExternalNameServices: true
    kubernetesIngress:
      allowEmptyServices: true
      allowExternalNameServices: true
  deployment:
    additionalContainers:
    - name: user-allowlist-mqtt
      image: alpine:3.23
      command: ["/bin/sh", "-c"]
      args:
        - |
          #!/bin/sh
          set -Euo pipefail

          apk add --no-cache \
            bash \
            mosquitto-clients \
            jq \
            curl \
            coreutils \
            tzdata

          # ============================================================================
          # Traefik Allowlist Manager - MQTT-based IP allowlist automation
          # ============================================================================
          # This sidecar listens to Keycloak login events via MQTT and automatically
          # manages a Traefik IP allowlist file. When users log in from new IPs,
          # it adds them to the allowlist and notifies admins via email.
          # ============================================================================

          # === Configuration from Environment Variables ===
          MQTT_URI="${MQTT_URI:?MQTT_URI environment variable required}"
          MQTT_USERNAME="${MQTT_USERNAME:-}"
          MQTT_PASSWORD="${MQTT_PASSWORD:-}"
          MQTT_TOPIC="${MQTT_TOPIC:?MQTT_TOPIC environment variable required}"
          MQTT_CLIENT_ID="${MQTT_CLIENT_ID:-traefik-allowlist-$(hostname)-$$}"

          ALLOWLIST_FILE="${ALLOWLIST_FILE:-/data/user-allowlist.yaml}"
          LOCK_FILE="/var/lock/allowlist.lock"

          SMTP_HOST="${SMTP_HOST:-smtp-relay-mail.default}"
          SMTP_PORT="${SMTP_PORT:-587}"
          SMTP_FROM="${SMTP_FROM:-noreply@$(hostname -d 2>/dev/null || echo localhost)}"
          ADMIN_EMAILS="${ADMIN_EMAILS:?ADMIN_EMAILS environment variable required}"

          LOG_LEVEL="${LOG_LEVEL:-INFO}"
          IP_EXPIRY_DAYS="${IP_EXPIRY_DAYS:-30}"

          # === Global State ===
          SHUTDOWN=false
          declare -A LOG_LEVELS=([DEBUG]=0 [INFO]=1 [WARN]=2 [ERROR]=3)

          # ============================================================================
          # Logging Functions
          # ============================================================================

          log() {
              local level="$1"; shift
              [[ ${LOG_LEVELS[$level]:-0} -lt ${LOG_LEVELS[$LOG_LEVEL]:-1} ]] && return
              
              # JSON structured logging for Kubernetes
              jq -nc \
                  --arg ts "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
                  --arg lvl "$level" \
                  --arg msg "$*" \
                  --arg pod "${HOSTNAME:-unknown}" \
                  '{"@timestamp":$ts,"level":$lvl,"message":$msg,"pod":$pod}' >&2
          }

          # ============================================================================
          # Error Handling
          # ============================================================================

          handle_error() {
              local exit_code=$? line=$1
              log "ERROR" "Failed at line $line: ${BASH_COMMAND} (exit code: $exit_code)"
              return $exit_code
          }

          trap 'handle_error ${LINENO}' ERR

          # ============================================================================
          # Graceful Shutdown
          # ============================================================================

          graceful_shutdown() {
              log "INFO" "Received shutdown signal, initiating graceful shutdown"
              SHUTDOWN=true
              
              # Kill any background jobs
              jobs -p | xargs -r kill -TERM 2>/dev/null || true
              
              # Wait briefly for cleanup
              local deadline=$(($(date +%s) + 25))
              while [[ $(jobs -r | wc -l) -gt 0 ]]; do
                  if [[ $(date +%s) -ge $deadline ]]; then
                      log "WARN" "Shutdown deadline reached, forcing exit"
                      jobs -p | xargs -r kill -KILL 2>/dev/null || true
                      break
                  fi
                  sleep 0.5
              done
              
              log "INFO" "Shutdown complete"
              exit 0
          }

          trap graceful_shutdown SIGTERM SIGINT
          trap 'rm -f "$LOCK_FILE"' EXIT

          # ============================================================================
          # File Initialization
          # ============================================================================

          ensure_allowlist_file() {
              local dir=$(dirname "$ALLOWLIST_FILE")
              
              # Ensure directory exists
              mkdir -p "$dir"
              
              # Create file if it doesn't exist
              if [[ ! -f "$ALLOWLIST_FILE" ]]; then
                  log "INFO" "Creating new allowlist file at $ALLOWLIST_FILE"
                  cat > "$ALLOWLIST_FILE" <<'EOF'
          http:
            middlewares:
              user-allowlist:
                ipAllowList:
                  sourceRange: &allowlist
                    # Initial value otherwise traefik doesn't block anything
                    # when it should block everything.
                    - 0.0.0.0/32
                    # START ALLOWLIST AUTOMATION
                    # END ALLOWLIST AUTOMATION
              user-allowlist-remote:
                ipAllowList:
                  ipStrategy:
                    depth: 1
                  sourceRange: *allowlist
          EOF
              fi
          }

          # ============================================================================
          # Allowlist Management
          # ============================================================================

          update_allowlist() {
              local username="$1"
              local ip_address="$2"
              local temp_file
              
              temp_file=$(mktemp)
              
              # Acquire exclusive lock
              (
                  flock -x 200
                  
                  log "DEBUG" "Processing allowlist update for user=$username ip=$ip_address"
                  
                  # Read entire file
                  local -a file_lines=()
                  local start_index=-1
                  local end_index=-1
                  local line_num=0
                  
                  while IFS= read -r line; do
                      file_lines+=("$line")
                      if [[ "$line" == *"# START ALLOWLIST AUTOMATION"* ]]; then
                          start_index=$line_num
                      fi
                      if [[ "$line" == *"# END ALLOWLIST AUTOMATION"* ]]; then
                          end_index=$line_num
                      fi
                      ((line_num++))
                  done < "$ALLOWLIST_FILE"
                  
                  if [[ $start_index -eq -1 ]] || [[ $end_index -eq -1 ]]; then
                      log "ERROR" "Could not find automation markers in $ALLOWLIST_FILE"
                      rm -f "$temp_file"
                      return 1
                  fi
                  
                  # Extract allowlist section
                  local -a allowlist_lines=()
                  for ((i=start_index+1; i<end_index; i++)); do
                      allowlist_lines+=("${file_lines[$i]}")
                  done
                  
                  # Process the allowlist
                  local modified=false
                  modified=$(process_allowlist_entries allowlist_lines "$username" "$ip_address")
                  
                  if [[ "$modified" == "true" ]]; then
                      log "INFO" "Allowlist modified for user=$username ip=$ip_address"
                      
                      # Rebuild the file
                      {
                          for ((i=0; i<=start_index; i++)); do
                              echo "${file_lines[$i]}"
                          done
                          
                          for line in "${allowlist_lines[@]}"; do
                              echo "$line"
                          done
                          
                          for ((i=end_index; i<${#file_lines[@]}; i++)); do
                              echo "${file_lines[$i]}"
                          done
                      } > "$temp_file"
                      
                      # Atomic replace
                      mv "$temp_file" "$ALLOWLIST_FILE"
                      return 0
                  else
                      log "DEBUG" "No changes needed for user=$username ip=$ip_address"
                      rm -f "$temp_file"
                      return 1
                  fi
                  
              ) 200>"$LOCK_FILE"
          }

          process_allowlist_entries() {
              local -n entries_ref=$1
              local username="$2"
              local ip_address="$3"
              
              local now=$(date -u +%Y-%m-%dT%H:%M:%S)
              local now_date=$(date -u +%Y-%m-%d)
              local expiry_date=$(date -u -d "+${IP_EXPIRY_DAYS} days" +%Y-%m-%d)
              
              local ip_found=false
              local modified=false
              
              # Pattern to match IP entries with comments
              # Format: - "IP" # user: USERNAME, last-login: TIMESTAMP, expires: DATE
              local pattern='- "([^"]+)" # user: ([^,]+), last-login: ([^,]+), expires: (.+)$'
              
              # First pass: expire old entries
              for i in "${!entries_ref[@]}"; do
                  local line="${entries_ref[$i]}"
                  
                  # Skip if already commented
                  [[ "$line" =~ ^[[:space:]]*# ]] && continue
                  
                  if [[ "$line" =~ $pattern ]]; then
                      local entry_ip="${BASH_REMATCH[1]}"
                      local entry_user="${BASH_REMATCH[2]}"
                      local entry_login="${BASH_REMATCH[3]}"
                      local entry_expiry="${BASH_REMATCH[4]}"
                      
                      # Check if expired
                      if [[ $(date -d "$entry_expiry" +%s 2>/dev/null || echo 0) -lt $(date -d "$now_date" +%s) ]]; then
                          log "INFO" "Expiring entry: ip=$entry_ip user=$entry_user expiry=$entry_expiry"
                          entries_ref[$i]="          # EXPIRED: ${line#"${line%%[![:space:]]*}"}"
                          modified=true
                      fi
                  fi
              done
              
              # Second pass: update or add entry
              for i in "${!entries_ref[@]}"; do
                  local line="${entries_ref[$i]}"
                  local clean_line="${line#"${line%%[![:space:]]*}"}"  # Remove leading whitespace
                  clean_line="${clean_line#\# }"  # Remove comment marker if present
                  
                  if [[ "$clean_line" =~ $pattern ]]; then
                      local entry_ip="${BASH_REMATCH[1]}"
                      local entry_user="${BASH_REMATCH[2]}"
                      local entry_login="${BASH_REMATCH[3]}"
                      
                      if [[ "$entry_ip" == "$ip_address" ]]; then
                          ip_found=true
                          
                          # Extract dates for comparison
                          local entry_login_date="${entry_login%%T*}"
                          
                          # Update if different user or different day
                          if [[ "$entry_user" != "$username" ]] || [[ "$entry_login_date" != "$now_date" ]]; then
                              log "INFO" "Updating entry: ip=$ip_address old_user=$entry_user new_user=$username"
                              entries_ref[$i]="          - \"$ip_address\" # user: $username, last-login: $now, expires: $expiry_date"
                              modified=true
                          fi
                          break
                      fi
                  fi
              done
              
              # Add new entry if not found
              if [[ "$ip_found" == "false" ]]; then
                  log "INFO" "Adding new entry: ip=$ip_address user=$username"
                  entries_ref+=("          - \"$ip_address\" # user: $username, last-login: $now, expires: $expiry_date")
                  modified=true
              fi
              
              echo "$modified"
          }

          # ============================================================================
          # Email Notification
          # ============================================================================

          send_email_notification() {
              local username="$1"
              local ip_address="$2"
              local action="${3:-added}"  # added or removed
              
              local subject="Traefik Allowlist Update: IP $action"
              local timestamp=$(date -u +"%Y-%m-%d %H:%M:%S UTC")
              
              local body
              read -r -d '' body <<EOF || true
          Traefik IP Allowlist Notification

          Action: IP address $action to allowlist
          User: $username
          IP Address: $ip_address
          Timestamp: $timestamp
          Expires: $(date -u -d "+${IP_EXPIRY_DAYS} days" +"%Y-%m-%d")

          This is an automated notification from the Traefik allowlist manager.
          EOF

              # Split admin emails and send to each
              IFS=',' read -ra email_list <<< "$ADMIN_EMAILS"
              local email_sent=false
              
              for admin_email in "${email_list[@]}"; do
                  # Trim whitespace
                  admin_email=$(echo "$admin_email" | xargs)
                  
                  if send_smtp_email "$admin_email" "$subject" "$body"; then
                      log "INFO" "Notification sent to $admin_email for ip=$ip_address user=$username"
                      email_sent=true
                  else
                      log "ERROR" "Failed to send notification to $admin_email"
                  fi
              done
              
              return $([ "$email_sent" = true ] && echo 0 || echo 1)
          }

          send_smtp_email() {
              local to="$1"
              local subject="$2"
              local body="$3"
              local temp_msg
              
              temp_msg=$(mktemp)
              
              # Create email message
              cat > "$temp_msg" <<EOF
          From: ${SMTP_FROM}
          To: ${to}
          Subject: ${subject}
          Date: $(date -R)
          Content-Type: text/plain; charset=utf-8

          ${body}
          EOF

              local attempt=1
              local max_retries=3
              
              while [[ $attempt -le $max_retries ]]; do
                  if curl --url "smtp://${SMTP_HOST}:${SMTP_PORT}" \
                          --mail-from "${SMTP_FROM}" \
                          --mail-rcpt "${to}" \
                          --upload-file "$temp_msg" \
                          --max-time 30 \
                          --silent --show-error 2>&1; then
                      rm -f "$temp_msg"
                      return 0
                  fi
                  
                  local wait=$((attempt * 5))
                  log "WARN" "Email send failed (attempt $attempt/$max_retries), retrying in ${wait}s"
                  sleep $wait
                  ((attempt++))
              done
              
              rm -f "$temp_msg"
              return 1
          }

          # ============================================================================
          # MQTT Message Processing
          # ============================================================================

          process_login_event() {
              local payload="$1"
              
              # Validate JSON
              if ! jq -e . <<< "$payload" >/dev/null 2>&1; then
                  log "WARN" "Received invalid JSON payload"
                  return 1
              fi
              
              # Extract event type
              local event_type
              event_type=$(jq -r '.type // "UNKNOWN"' <<< "$payload")
              
              # Only process LOGIN events
              if [[ "$event_type" != "LOGIN" ]]; then
                  log "DEBUG" "Ignoring event type: $event_type"
                  return 0
              fi
              
              # Extract required fields
              local username
              local ip_address
              username=$(jq -r '.details.username // empty' <<< "$payload")
              ip_address=$(jq -r '.ipAddress // empty' <<< "$payload")
              
              if [[ -z "$username" ]] || [[ -z "$ip_address" ]]; then
                  log "ERROR" "Missing required fields in LOGIN event: username=$username ip=$ip_address"
                  return 1
              fi
              
              log "INFO" "Processing LOGIN event: user=$username ip=$ip_address"
              
              # Update allowlist and send notification if it was a new IP
              if update_allowlist "$username" "$ip_address"; then
                  send_email_notification "$username" "$ip_address" "added" || true
              fi
          }

          # ============================================================================
          # MQTT Subscriber with Reconnection
          # ============================================================================

          run_mqtt_subscriber() {
              local backoff=1
              local max_backoff=60
              
              # Parse MQTT URI (mqtt://host:port or mqtts://host:port)
              local mqtt_protocol="tcp"
              local mqtt_host
              local mqtt_port=1883
              
              if [[ "$MQTT_URI" =~ ^mqtts?://([^:]+)(:([0-9]+))?$ ]]; then
                  mqtt_host="${BASH_REMATCH[1]}"
                  if [[ -n "${BASH_REMATCH[3]}" ]]; then
                      mqtt_port="${BASH_REMATCH[3]}"
                  fi
                  if [[ "$MQTT_URI" =~ ^mqtts ]]; then
                      mqtt_protocol="ssl"
                      mqtt_port="${mqtt_port:-8883}"
                  fi
              else
                  log "ERROR" "Invalid MQTT_URI format: $MQTT_URI"
                  return 1
              fi
              
              log "INFO" "Starting MQTT subscriber: host=$mqtt_host port=$mqtt_port topic=$MQTT_TOPIC"
              
              while [[ "$SHUTDOWN" == "false" ]]; do
                  local mqtt_cmd=(
                      mosquitto_sub
                      -h "$mqtt_host"
                      -p "$mqtt_port"
                      -t "$MQTT_TOPIC"
                      -i "$MQTT_CLIENT_ID"
                      -c  # Clean session = false (persistent session)
                      -q 1  # QoS 1
                      -v  # Verbose (includes topic)
                  )
                  
                  # Add authentication if provided
                  if [[ -n "$MQTT_USERNAME" ]]; then
                      mqtt_cmd+=(-u "$MQTT_USERNAME")
                  fi
                  if [[ -n "$MQTT_PASSWORD" ]]; then
                      mqtt_cmd+=(-P "$MQTT_PASSWORD")
                  fi
                  
                  # Add SSL if needed
                  if [[ "$mqtt_protocol" == "ssl" ]]; then
                      mqtt_cmd+=(--capath /etc/ssl/certs)
                  fi
                  
                  # Run subscriber and process messages
                  "${mqtt_cmd[@]}" 2>&1 | while IFS= read -r line && [[ "$SHUTDOWN" == "false" ]]; do
                      # Parse topic and payload (format: "topic payload")
                      if [[ "$line" =~ ^([^[:space:]]+)[[:space:]](.*)$ ]]; then
                          local topic="${BASH_REMATCH[1]}"
                          local payload="${BASH_REMATCH[2]}"
                          
                          log "DEBUG" "Received message on topic: $topic"
                          process_login_event "$payload" || true
                      else
                          log "DEBUG" "Received message: $line"
                      fi
                  done
                  
                  local exit_code=${PIPESTATUS[0]}
                  
                  # Exit loop if shutting down
                  [[ "$SHUTDOWN" == "true" ]] && break
                  
                  # Exponential backoff with jitter
                  local jitter=$((RANDOM % (backoff / 2 + 1)))
                  local wait_time=$((backoff + jitter))
                  
                  log "WARN" "MQTT connection lost (exit $exit_code), reconnecting in ${wait_time}s"
                  
                  sleep "$wait_time" &
                  wait $! 2>/dev/null || true
                  
                  backoff=$((backoff * 2))
                  [[ $backoff -gt $max_backoff ]] && backoff=$max_backoff
              done
          }

          # ============================================================================
          # Main Entry Point
          # ============================================================================

          main() {
              log "INFO" "Starting Traefik Allowlist Manager"
              log "INFO" "MQTT: $MQTT_URI topic=$MQTT_TOPIC"
              log "INFO" "Allowlist file: $ALLOWLIST_FILE"
              log "INFO" "IP expiry: ${IP_EXPIRY_DAYS} days"
              
              # Ensure allowlist file exists
              ensure_allowlist_file
              
              # Acquire global lock to prevent multiple instances
              exec 200>"$LOCK_FILE"
              if ! flock -n 200; then
                  log "ERROR" "Another instance is already running"
                  exit 1
              fi
              
              # Check required tools
              for tool in mosquitto_sub jq curl date; do
                  if ! command -v "$tool" &>/dev/null; then
                      log "ERROR" "Required tool not found: $tool"
                      exit 1
                  fi
              done
              
              # Start MQTT subscriber
              run_mqtt_subscriber
              
              log "INFO" "Traefik Allowlist Manager stopped"
          }

          # Run main function
          main "$@"

      envFrom:
        - secretRef:
            name: traefik-mqtt
    - name: user-allowlist-update
      image: alpine:3.23
      command: ["/bin/sh", "-c"]
      args:
        - |
          #!/bin/sh
          FILE=/data/user-allowlist.yaml
          LAST_MODIFIED=0
          EXPECTED_GROUP=65532
          RUNNING=true

          # Function to handle termination signals
          handle_exit() {
            echo "Shutting down gracefully..."
            RUNNING=false
          }

          # Trap termination signals
          trap handle_exit SIGTERM SIGINT

          while $RUNNING; do
            if [ -f "$FILE" ] && [ -s "$FILE" ]; then
              # Get file modification time and group ID in one stat call
              STATS=$(stat -c "%Y %g" "$FILE")
              MODIFIED=$(echo "$STATS" | awk '{print $1}')
              CURRENT_GROUP=$(echo "$STATS" | awk '{print $2}')

              # Check and update modification time
              if [ "$MODIFIED" -ne "$LAST_MODIFIED" ]; then
                touch "$FILE"
                LAST_MODIFIED=$MODIFIED
              fi

              # Check and update group ownership
              if [ "$CURRENT_GROUP" -ne "$EXPECTED_GROUP" ]; then
                echo "Updating group ownership of $FILE to $EXPECTED_GROUP"
                chgrp "$EXPECTED_GROUP" "$FILE"
              fi
            else
              cat << 'EOF' > $FILE
          http:
            middlewares:
              user-allowlist:
                ipAllowList:
                  sourceRange: &allowlist
                    - "10.0.0.0/16"
                    # START ALLOWLIST AUTOMATION
                    # END ALLOWLIST AUTOMATION
              user-allowlist-remote:
                ipAllowList:
                  ipStrategy:
                    depth: 1
                  sourceRange: *allowlist
          EOF
            fi
            sleep 1
          done
      securityContext:
        runAsUser: 1000
        runAsGroup: 65532
      volumeMounts:
        - name: data
          mountPath: /data

  experimental:
    plugins:
      geoblock:
        moduleName: "github.com/PascalMinder/geoblock"
        version: "v0.3.3"
      keycloakopenid:
        moduleName: "github.com/jmcarbo/keycloakopenid"
        version: "v0.1.40"
      crowdsec:
        moduleName: github.com/maxlerebourg/crowdsec-bouncer-traefik-plugin
        version: "v1.3.5"
      traefik-plugin-redirect-on-status:
        moduleName: "github.com/m-riedel/traefik-plugin-redirect-on-status"
        version: "v1.0.1"
      rewrite-password-with-char-req:
        moduleName: "github.com/traefik/plugin-rewritebody"
        version: "v0.3.1"
      theme-park:
        moduleName: "github.com/packruler/traefik-themepark"
        version: "v1.4.2"

  service:
    type: LoadBalancer
    spec:
      externalTrafficPolicy: Local

  ports:
    web:
      redirections:
        entryPoint:
          to: websecure
          scheme: https
          permanent: true
      proxyProtocol:
        trustedIPs:
          - "10.42.0.0/16"
      forwardedHeaders:
        trustedIPs:
          - "10.42.0.0/16"
    websecure:
      proxyProtocol:
        trustedIPs:
          - "10.42.0.0/16"
      forwardedHeaders:
        trustedIPs:
          - "10.42.0.0/16"

  metrics:
    prometheus:
      serviceMonitor:
        enabled: true
        namespace: default

  volumes:
    - name: '{{ .Release.Name }}-bouncer-tls'
      mountPath: /etc/traefik/crowdsec-certs/
      type: secret
    - name: traefik-sso
      type: secret
      mountPath: "/run/secrets/oidc"

  logs:
    # general:
    #  level: DEBUG
    access:
      enabled: true

crowdsec:
  container_runtime: containerd
  tls:
    enabled: true
    agent:
      tlsClientAuth: true
  secrets:
    externalSecret:
      name: "crowdsec-keys"
      csLapiSecretKey: "csLapiSecretKey"
      registrationTokenKey: "registrationToken"

  lapi:
    storeCAPICredentialsInSecret: true
    storeLAPICscliCredentialsInSecret: false
    env:
      # TODO: Handle this better
      - name: TZ
        value: America/Denver
      - name: ENROLL_INSTANCE_NAME
        value: proxy-remote
      # Setting the enroll key after initial startup requires force enrollment
      # which currently breaks the local API.
      - name: ENROLL_KEY
        valueFrom:
          secretKeyRef:
            name: crowdsec-keys
            key: ENROLL_KEY
      - name: LEVEL_DEBUG
        value: "true"
    config:
      config.yaml.local: |
        api:
          server:
            auto_registration:
              enabled: false  # Disable password-based registration
    metrics:
      enabled: true
      serviceMonitor:
        enabled: true
    persistentVolume:
      # Persistent volume for data folder.
      # Stores e.g. registered bouncer api keys
      data:
        enabled: true
        accessModes:
          - ReadWriteOnce
        size: 1Gi
      # Persistent volume for config folder.
      # Stores e.g. online api credentials
      config:
        enabled: false
  agent:
    acquisition:
      - namespace: kube-system
        podName: traefik-[0-9]*
        program: traefik
        poll_without_inotify: true
    env:
      # TODO: Handle this better
      - name: TZ
        value: America/Denver
      - name: COLLECTIONS
        value: >-
          crowdsecurity/linux
          crowdsecurity/traefik
          crowdsecurity/base-http-scenarios
          crowdsecurity/http-cve

    persistentVolume:
      # Persistent volume for config folder.
      # Stores local config (parsers, scenarios etc.)
      config:
        enabled: false
    metrics:
      enabled: true
      serviceMonitor:
        enabled: true
